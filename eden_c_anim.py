# -*- coding: utf-8 -*-
"""Eden C Anim.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tGnUu5D7glaGOucEKDn_NVlXSfrHOzWM
"""

import numpy as np
import matplotlib.pyplot as plt
import random as rand
from matplotlib.animation import FuncAnimation
from scipy.optimize import curve_fit

"""# Eden C (Funciones)"""

def move(positions_list, ind_activo, options,tracker_gen):
      """Función que toma una lista de posiciones con un elemento inicial, chequea el entorno y elige aleatoriamente entre espacios libres. Luego, añade el índice
      de la partícula (cada índice sería el largo de la lista posiciones) a una lista de índices. Además, anota la información genealógica de cada partícula"""

      # Primero realizamos un test sobre el entorno a la hora de moverse.
      # Si solo hay un índide activo, se le da la etiqueta 0, ya que es la partícula inicial.

      if len(ind_activo)==1:
          indice=0
      else:
          indice = rand.choice(ind_activo)

      # Construiremos un árbol genealógica de modo que cada posición tenga contacto con sus ancestros

      if indice == 0:
        ancestros = tracker_gen[0]
      else:
        ancestros = tracker_gen[indice]

      # Añadimos el rotulo de la nueva partícula a la lista con la genealogía

      tracker_gen.append(ancestros + [len(positions_list)])

      #--------------------------------------------------------------------------

      # Con la particula activa escogida, la asociamos a la posición

      position = positions_list[indice]

      # Exploramos las opciones y descartamos aquellos lugares donde haya otra partícula

      indexrip =[] # Lista con los índices de lugares ocupados
      for i, option in enumerate(options):
        lugar_hipotetico= position + option
        test = np.all(np.isclose(lugar_hipotetico, positions_list, rtol=1e-05, atol=1e-08, equal_nan=False), axis=1)
        if test.any():
           indexrip.append(i)
        else:
           pass

      # Finalmente eliminamos espacios que ya están ocupados

      options = np.delete(options, indexrip,axis=0)
      j = np.random.randint(len(options))

      # Se elige entre las posiciones no eliminadas aleatoriamente

      nueva_pos = np.array([(position + options[j])])
      positions_list = np.append(positions_list, nueva_pos, axis=0) # Y se agrega a la lista de posiciones
      ind_activo.append(len(positions_list)-1)
      return positions_list

def check_vecinos(ind_activo, positions_list, options):
    """Toma la lista de posiciones y chequea el entorno de cada partícula individual.
      Si hay espacios libres, no hace nada. Si no hay espacios libres elimina a aquella partícula de las partículas activas."""

    ripindex =[]
    for i, j in enumerate(ind_activo):
      test = all(any(np.all(np.isclose(positions_list[j] + k,positions_list, rtol=1e-05, atol=1e-08, equal_nan=False), axis=1)) for k in options)
      if test:
        ripindex.append(i)
      else:
        pass
    for v in sorted(ripindex, reverse=True): # Arreglamos el problema de los índices eliminando desde adelante, así no cambian los de atrás
      ind_activo.pop(v)
    return ind_activo

# Simulación

def simulacion(grilla_type, N):
  '''Función que dado un tipo de grilla y un número de partículas hace una simulación tipo Eden-C, entregando la
  lista de posiciones, índices de particulas activas y resultados (radios_prom, número de partículas activas y varianza)'''

  # Condiciones

  ang = np.pi/3
  hexagon=np.array([(np.cos(0*ang),np.sin(0*ang)),(np.cos(ang),np.sin(ang)),(np.cos(2*ang),np.sin(2*ang)),(np.cos(3*ang),np.sin(3*ang)), (np.cos(4*ang),np.sin(4*ang)), (np.cos(5*ang),np.sin(5*ang)), (np.cos(6*ang),np.sin(6*ang))])
  grilla= np.array([(1,0), (0,1), (0,-1), (-1,0)])
  if grilla_type == 'cuadrada':
    options = grilla
  elif grilla_type == 'triangular':
    options = hexagon
  N_part = 1
  ind_activo = [0]
  positions_list = np.array([(0,0)])
  results = []
  tracker_gen = [[0]]
  # -------------------------------

  N_part = 1
  while N_part < N:
    a = move(positions_list, ind_activo, options, tracker_gen)
    positions_list = a
    b = check_vecinos(ind_activo, positions_list, options)
    ind_activo = b
    N_part = N_part+1

    # Realizaremos una transformación para obtener los radios
    radios = np.array([])
    for pos in positions_list[ind_activo,:]:
      radio = np.sqrt(pos[0]**2 + pos[1]**2)
      radios = np.append(radios, radio)

    # Promedio
    radio_prom = np.mean(radios)
    radio_var = np.std(radios)
    arreglo = [radio_prom, len(ind_activo), radio_var]
    results.append(arreglo)
  results=np.array(results)

  return positions_list, ind_activo, results, radio_prom, tracker_gen

"""# Animación"""

# Simulación
N_total = 1000
positions_list, ind_activo, results, radio_prom, tracker_gen = simulacion('triangular', N_total)

# Animación

fig, ax = plt.subplots()
sc = ax.scatter([], [])

# Posiciones en los ejes

x = positions_list[:,0]
y = positions_list[:,1]

# Se guardan las posiciones en cada frame

posiciones_animacion = []

# Creamos los límites del gráfico y le damos tolerancia.

def init():
    ax.set_xlim(min(x-1), max(x+1))
    ax.set_ylim(min(y-1), max(y+1))
    return sc,

# Función de animación
def update(frame):
    posiciones_animacion.append(positions_list[frame])
    sc.set_offsets(posiciones_animacion)
    return sc,

# Crear la animación
ani = FuncAnimation(fig, update, frames=len(x), init_func=init, blit=True)

total_time = 8
fps = len(x)/total_time

# Guardar la animación como un archivo de video
ani.save('scatter_animation.mp4', fps=fps, extra_args=['-vcodec', 'libx264'])

plt.show()